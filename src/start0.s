.text
/*.align 0x100*/
.globl _start0
.type _start0, @function
_start0:  /* The .c32 executable must start with this as its entry point. */
/* 00000000  B8FE4CCD21        mov eax,0x21cd4cfe */
.byte 0xb8, 0xfe, 0x4c, 0xcd, 0x21  /* COM32R signature. */
cld

/* At this point the following instructions will be inserted by
 * relocate_tinyc32_elf in tinyc32:
 * .byte 0xe8; .long 0  -- call next_instruction.
 * .byte 0x5b  -- pop ebx.
 * One or more of these autogenerated relocation instructions:
 * .byte 0x01, 0x9b; .long ...  -- add [dword ebx + ...], ebx.
 * Zero or more of these (or a jump + nops):
 * .byte 0x90  -- nop, to align the rest.
 */

/* This must be the very first instruction after the cld, tinyc32 needs it. */
mov $__bss_size, %ecx
mov $__bss_start, %edi
xor %eax, %eax
/* Unfortunately, `mov _end-__bss_start, %ecx' doesn't work. (It doesn't work
 * in C either with externs.) It would be
 * better, because it would be 0 relocations.
 * mov _end, %ecx
 * sub %edi, %ecx
 * -- mov $__bss_size, %ecx  ; This also does a relocation (which we don't want).
 */
rep stosb

/* We copy useful function pointers and input variables Syslinux
 * provides us by the COM32R ABI (details:
 * http://www.syslinux.org/doc/comboot.txt ) to our csargs_all.
 *
 * The layout of csargs_all is found in `struct csargs_all' in
 * include/tinyc32.h .
 *
 * TODO(pts): Don't copy to csargs_all, just retain a pointer.
 */
lea 8(%esp), %esi
lea csargs_all, %edi
mov 16(%esp), %eax
shr $4, %eax
/* Fill csargs_all.cs_bounce_seg. */
stos %eax, %es:(%edi)  /* .byte 0xab */   /* stosd */
mov $8, %ecx
/* Copy over to csargs_all.cs_cmdline .. .cs_name . */
rep movsd
mov 40(%esp), %esi
add $4, %esi
/* mov csargs_all + 9 * 4, %edi */  /* Not needed, already correct. */
mov $14, %ecx
/* Copy over to csargs_all.lmalloc .. .ms_timer . */
rep movsd

jmp _start  /* Jump to the C function void _start() { ... } by the user. */

.set  csargs_all_size, 23 * 4  /* Not needed, FYI only. */
.comm csargs_all, csargs_all_size, 1
