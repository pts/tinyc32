#! /bin/bash --
# by pts@fazekas.hu at Sat Dec 16 19:14:56 CET 2017
export DO_DELTA=0
# Some comments about relocations:
# * Both `add %eax, (...)' and `add %ebx, (...)' have a 2-byte prefix.
# * TODO(pts): Can we do better than `-.text' below? E.g. current section?
export RELOC_PL='
print "/* Autogenerated file, do not edit. */\n";
print ".byte 0xe8, 0, 0, 0, 0
after_reloc_call:
pop %ebx
.byte 0x83, 0xeb, after_reloc_call-.text  /* Short: sub ebx, ... */\n";
my @l;
while (<STDIN>) {
  chomp;
  my($addr,$type,$symbol)=split(/ +/, $_, 3);
  next if !defined($addr) or $addr !~ /^[0-9a-fA-F]{8,}$/;
  if ($type eq "R_386_32") {
    # Like "add %ebx, 0x$addr(%ebx)\n", but always 6 bytes.
    push @l, [hex($addr), $symbol];
  } elsif ($type eq "R_386_PC32") {
  } else {
    die "error: unknown relocation type $addr in: $_\n";
  }
}
die "error: no relocations\n" if !@l;
my $delta = $ENV{DO_DELTA} ? 11 + 6 * @l : 0;
for my $item (@l) {
  my($addr,$symbol) = @$item;
  printf ".byte 0x01, 0x9B; .long 0x%x  /* symbol $symbol */\n", $addr + $delta;
}
# We need this jump to flush the prefetch queue:
# https://stackoverflow.com/a/43241919/97248
# Pentium 6 is smart enough without this jump, but we want to be backwards-
# compatible.
print ".byte 0xeb, 0  /* jmp short next_instruction */\n";
print "/* end of relocations */\n";
'
# Add all .c and .s files. Omit start0.s here, it changes via reloc.s below,
# so it has to be recompiled. Also omit reloc.s, it's included from start0.s.
#IFS='
#'
export TINYC32DIR="${0%/*}"  # TODO(pts): Process symlinks.
set -ex
# TODO(pts): Better whitespace splitting. Use arrays.
SRCS="$@"
# No `-s', it prevents `objdump -r' from working.
COMPILE_CMD="gcc -Wl,-Ttext=0 -Wl,-e,_start0 -Wl,-N -Wl,--build-id=none -Wl,-q -m32 -march=i686 -static -nostdlib -nostdinc -W -Wall -Wextra -Werror -Os -fno-stack-protector -fomit-frame-pointer -fno-ident -fno-unwind-tables -fno-asynchronous-unwind-tables -Os -falign-functions=1 -mpreferred-stack-boundary=2 -falign-jumps=1 -falign-loops=1 -ffunction-sections -fdata-sections -Wl,--gc-sections -isystem $TINYC32DIR/include"
LIBS="$TINYC32DIR/cs_print.s $TINYC32DIR/cs_putc.s"
: >"$TINYC32DIR/reloc".s
<"$TINYC32DIR/start0.s" >start0tmp.s perl -0777 -pe '
    s@^[.]include "reloc[.]s".*$@@mg'
#$COMPILE_CMD -c start0tmp.s $SRCS
$COMPILE_CMD -o prog.elf start0tmp.s $SRCS $LIBS
# TODO(pts): Write pure Python code instead of objdump and objcopy.
objdump -r prog.elf | >reloctmp.s1 DO_DELTA=1 perl -we 'eval $ENV{RELOC_PL}; die $@ if $@'
<"$TINYC32DIR/start0.s" >start0tmp.s perl -0777 -pe '
    our $rs; BEGIN { die if !open(F, "<", "reloctmp.s1"); $rs = join("", <F>) }
    s@^[.]include "reloc[.]s".*$@$rs@mg'
$COMPILE_CMD -o prog.elf start0tmp.s $SRCS $LIBS
objdump -r prog.elf | >reloctmp.s2 perl -we 'eval $ENV{RELOC_PL}; die $@ if $@'
# Usually we can manage by just doing 2 compilations and not the 3rd one below,
# because DO_DELTA=1 guesses the offsets correctly. But if there is alignment
# in .text, then we probably need a 3rd compilation, because the offset after
# reloctmp.s is not divisible by 4.
if ! diff reloctmp.s1 reloctmp.s2; then
  : 'info: Doing a 3rd compilation. Remove alignment to omit it.'
  <"$TINYC32DIR/start0.s" >start0tmp.s perl -0777 -pe '
      our $rs; BEGIN { die if !open(F, "<", "reloctmp.s2"); $rs = join("", <F>) }
      s@^[.]include "reloc[.]s".*$@$rs@mg'
  $COMPILE_CMD -o prog.elf start0tmp.s $SRCS $LIBS
  objdump -r prog.elf | >reloctmp.s3 perl -we 'eval $ENV{RELOC_PL}; die $@ if $@'
  diff reloctmp.s2 reloctmp.s3
fi
objcopy -O binary prog.elf prog.c32
chmod 644 prog.c32
rm -f reloctmp.s1 reloctmp.s2 reloctmp.s3 start0tmp.s prog.elf
: tinyc32 compilation OK, output is: prog.c32
